name: Generate GitHub Traffic Badges

on:
  schedule:
    - cron: "0 0 * * *" # Runs daily at midnight UTC to collect new data
  workflow_dispatch: # Allows manual triggering

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: write # Required to commit changes to the repository
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate and Commit Traffic Data
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // The 'exec' function is automatically provided by actions/github-script@v7.
            // No need to 'require' it.
            const fs = require('fs');
            const path = require('path');

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const badgeDir = '.github/badges';
            const historyFile = '.github/traffic_history.json';

            /**
             * Writes a file locally to the runner's filesystem.
             */
            function writeFile(filePath, content) {
              const dir = path.dirname(filePath);
              if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir, { recursive: true });
              }
              fs.writeFileSync(filePath, content);
              console.log(`- Wrote local file: ${filePath}`);
            }

            /**
             * Creates a themed SVG badge.
             */
            function createBadgeSvg(label, message, color) {
              const labelWidth = label.length * 7 + 12;
              const messageWidth = message.length * 7.5 + 12;
              const totalWidth = labelWidth + messageWidth;
              const labelBgColor = '#4C566A';
              const textColor = '#ECEFF4';
              const shadowColor = '#2E3440';
              return `
                <svg xmlns="http://www.w3.org/2000/svg" width="${totalWidth}" height="20" role="img" aria-label="${label}: ${message}">
                  <title>${label}: ${message}</title>
                  <linearGradient id="s" x2="0" y2="100%"><stop offset="0" stop-color="#bbb" stop-opacity=".1"/><stop offset="1" stop-opacity=".1"/></linearGradient>
                  <clipPath id="r"><rect width="${totalWidth}" height="20" rx="3" fill="#fff"/></clipPath>
                  <g clip-path="url(#r)">
                    <rect width="${labelWidth}" height="20" fill="${labelBgColor}"/><rect x="${labelWidth}" width="${messageWidth}" height="20" fill="${color}"/><rect width="${totalWidth}" height="20" fill="url(#s)"/>
                  </g>
                  <g fill="${textColor}" text-anchor="middle" font-family="Verdana,Geneva,DejaVu Sans,sans-serif" text-rendering="geometricPrecision" font-size="110">
                    <text aria-hidden="true" x="${(labelWidth/2)*10}" y="150" fill="${shadowColor}" fill-opacity=".3" transform="scale(.1)" textLength="${(labelWidth-10)*10}">${label}</text>
                    <text x="${(labelWidth/2)*10}" y="140" transform="scale(.1)" textLength="${(labelWidth-10)*10}">${label}</text>
                    <text aria-hidden="true" x="${(labelWidth+messageWidth/2)*10}" y="150" fill="${shadowColor}" fill-opacity=".3" transform="scale(.1)" textLength="${(messageWidth-10)*10}">${message}</text>
                    <text x="${(labelWidth+messageWidth/2)*10}" y="140" transform="scale(.1)" textLength="${(messageWidth-10)*10}">${message}</text>
                  </g>
                </svg>`;
            }

            // Main execution logic
            try {
              // --- 1. Load historical data ---
              console.log(`Loading historical data from ${historyFile}...`);
              let historicalData = { clones: {}, views: {}, releases: { total_downloads: 0, by_release: {} } };
              let originalHistoryContent = '';
              if (fs.existsSync(historyFile)) {
                originalHistoryContent = fs.readFileSync(historyFile, 'utf8');
                const loadedData = JSON.parse(originalHistoryContent);
                historicalData.clones = loadedData.clones || {};
                historicalData.views = loadedData.views || {};
                historicalData.releases = loadedData.releases || { total_downloads: 0, by_release: {} };
                console.log('Successfully loaded existing historical data.');
              } else {
                console.log('No historical data file found. A new one will be created.');
              }

              // --- 2. Fetch new API data ---
              console.log('Fetching latest data from GitHub API...');
              const { data: clonesResponse } = await github.rest.repos.getClones({ owner, repo, per: 'day' });
              const { data: viewsResponse } = await github.rest.repos.getViews({ owner, repo, per: 'day' });
              const releases = await github.paginate(github.rest.repos.listReleases, { owner, repo });

              const newApiDataByRelease = {};
              for (const release of releases) {
                const assetsData = {};
                for (const asset of release.assets) {
                  assetsData[asset.name] = asset.download_count;
                }
                if (release.tag_name) {
                  newApiDataByRelease[release.tag_name] = { assets: assetsData };
                }
              }

              // --- 3. Accumulate Download Counts ---
              console.log('Calculating new cumulative download counts...');
              const cumulativeReleasesData = historicalData.releases.by_release || {};

              for (const [tagName, newReleaseData] of Object.entries(newApiDataByRelease)) {
                if (!cumulativeReleasesData[tagName]) {
                  cumulativeReleasesData[tagName] = { total_downloads: 0, assets: {} };
                }
                const historicalRelease = cumulativeReleasesData[tagName];

                for (const [assetName, newAssetCount] of Object.entries(newReleaseData.assets)) {
                  const oldAssetCount = historicalRelease.assets[assetName] || 0;
                  historicalRelease.assets[assetName] = Math.max(oldAssetCount, newAssetCount);
                }

                historicalRelease.total_downloads = Object.values(historicalRelease.assets).reduce((sum, count) => sum + count, 0);
              }

              const cumulativeTotalDownloads = Object.values(cumulativeReleasesData).reduce((sum, release) => sum + release.total_downloads, 0);

              historicalData.releases = {
                  total_downloads: cumulativeTotalDownloads,
                  by_release: cumulativeReleasesData
              };

              // --- 4. Update Clones and Views ---
              clonesResponse.clones.forEach(day => {
                historicalData.clones[day.timestamp.split('T')[0]] = { count: day.count, uniques: day.uniques };
              });
              viewsResponse.views.forEach(day => {
                historicalData.views[day.timestamp.split('T')[0]] = { count: day.count, uniques: day.uniques };
              });

              // --- 5. Check for changes before committing ---
              const newHistoryContent = JSON.stringify(historicalData, null, 2);
              if (newHistoryContent.trim() === originalHistoryContent.trim()) {
                  console.log('✅ No changes detected in traffic or download data. Nothing to commit.');
                  return;
              }

              // --- 6. Generate SVGs from final data ---
              console.log('Data has changed. Generating new badges...');
              const allTimeTotalClones = Object.values(historicalData.clones).reduce((sum, day) => sum + day.count, 0);
              const allTimeTotalViews = Object.values(historicalData.views).reduce((sum, day) => sum + day.count, 0);

              writeFile(historyFile, newHistoryContent);
              writeFile(`${badgeDir}/clones_badge.svg`, createBadgeSvg('Clones', `${allTimeTotalClones}`, '#8FBCBB'));
              writeFile(`${badgeDir}/views_badge.svg`, createBadgeSvg('Views', `${allTimeTotalViews}`, '#88C0D0'));
              writeFile(`${badgeDir}/total_downloads_badge.svg`, createBadgeSvg('Total Downloads', `${historicalData.releases.total_downloads}`, '#A3BE8C'));

              for (const [tagName, data] of Object.entries(historicalData.releases.by_release)) {
                  const safeTagName = tagName.replace(/[^a-zA-Z0-9.-]/g, '_');
                  const badgePath = `${badgeDir}/release_${safeTagName}_badge.svg`;
                  const svgContent = createBadgeSvg(`Downloads ${tagName}`, `${data.total_downloads}`, '#B48EAD');
                  writeFile(badgePath, svgContent);
              }

              // --- 7. Commit all changes in one commit ---
              console.log('Committing all changes to the repository...');
              await exec('git', ['config', '--global', 'user.name', 'github-actions[bot]']);
              await exec('git', ['config', '--global', 'user.email', 'github-actions[bot]@users.noreply.github.com']);
              await exec('git', ['add', '.']);
              await exec('git', ['commit', '-m', 'feat: Update GitHub traffic and download badges']);
              await exec('git', ['push']);

              console.log('✅ Traffic badges, download counts, and history updated successfully in a single commit!');

            } catch (error) {
              console.error('Error during workflow execution:', error);
              core.setFailed(`Action failed with error: ${error.message}`);
            }
