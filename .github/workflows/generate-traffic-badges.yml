# .github/workflows/generate-traffic-badges.yml

name: Generate GitHub Traffic Badges

on:
  schedule:
    - cron: "0 0 * * *" # Runs daily at midnight UTC to collect new data
  workflow_dispatch: # Allows manual triggering

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: write # Required to commit changes to the repository
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # Fetch all history to ensure the script has the full context.
          fetch-depth: 0

      - name: Generate and Commit Traffic Data
        uses: actions/github-script@v7 # Using a more recent version
        with:
          github-token: ${{ secrets.GH_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const badgeDir = '.github/badges';
            const historyFile = '.github/traffic_history.json';
            const branch = context.ref.replace('refs/heads/', ''); // Get current branch name

            /**
             * Fetches a file's content and SHA from the repository.
             * @param {string} filePath - The path to the file in the repo.
             * @returns {Promise<{content: string|null, sha: string|null}>}
             */
            async function getFile(filePath) {
              try {
                const response = await github.rest.repos.getContent({
                  owner,
                  repo,
                  path: filePath,
                  ref: branch, // Fetch from the current branch
                });
                if (response.data && response.data.content) {
                  return {
                    content: Buffer.from(response.data.content, 'base64').toString('utf8'),
                    sha: response.data.sha
                  };
                }
                return { content: null, sha: null };
              } catch (error) {
                if (error.status === 404) {
                  // File doesn't exist, which is a valid case
                  return { content: null, sha: null };
                }
                // Re-throw other unexpected errors
                console.error(`Error getting file ${filePath}:`, error);
                throw error;
              }
            }

            /**
             * Commits a file to the repository, creating or updating it.
             * @param {string} filePath - The path for the file.
             * @param {string} content - The new content of the file.
             * @param {string} message - The commit message.
             * @param {string|null} sha - The SHA of the existing file, or null to create a new one.
             */
            async function commitFile(filePath, content, message, sha) {
              await github.rest.repos.createOrUpdateFileContents({
                owner,
                repo,
                path: filePath,
                message: message,
                content: Buffer.from(content).toString('base64'),
                sha: sha, // The API handles a null sha for new file creation
                branch: branch,
              });
            }

            /**
             * Creates a themed SVG badge.
             * @param {string} label - The text for the left part of the badge.
             * @param {string} message - The text for the right part of the badge.
             * @param {string} color - The background color for the message part.
             * @returns {string} - The SVG content as a string.
             */
            function createBadgeSvg(label, message, color) {
                const labelWidth = label.length * 7 + 12;
                const messageWidth = message.length * 7.5 + 12; // Adjusted for better spacing
                const totalWidth = labelWidth + messageWidth;

                const primaryBgColor = '#3B4252';
                const labelBgColor = '#4C566A';
                const textColor = '#ECEFF4';
                const shadowColor = '#2E3440';

                return `
                  <svg xmlns="http://www.w3.org/2000/svg" width="${totalWidth}" height="20" role="img" aria-label="${label}: ${message}">
                    <title>${label}: ${message}</title>
                    <linearGradient id="s" x2="0" y2="100%">
                      <stop offset="0" stop-color="#bbb" stop-opacity=".1"/>
                      <stop offset="1" stop-opacity=".1"/>
                    </linearGradient>
                    <clipPath id="r"><rect width="${totalWidth}" height="20" rx="3" fill="#fff"/></clipPath>
                    <g clip-path="url(#r)">
                      <rect width="${labelWidth}" height="20" fill="${labelBgColor}"/>
                      <rect x="${labelWidth}" width="${messageWidth}" height="20" fill="${color}"/>
                      <rect width="${totalWidth}" height="20" fill="url(#s)"/>
                    </g>
                    <g fill="${textColor}" text-anchor="middle" font-family="Verdana,Geneva,DejaVu Sans,sans-serif" text-rendering="geometricPrecision" font-size="110">
                      <text aria-hidden="true" x="${(labelWidth / 2) * 10}" y="150" fill="${shadowColor}" fill-opacity=".3" transform="scale(.1)" textLength="${(labelWidth - 10) * 10}">${label}</text>
                      <text x="${(labelWidth / 2) * 10}" y="140" transform="scale(.1)" textLength="${(labelWidth - 10) * 10}">${label}</text>
                      <text aria-hidden="true" x="${(labelWidth + messageWidth / 2) * 10}" y="150" fill="${shadowColor}" fill-opacity=".3" transform="scale(.1)" textLength="${(messageWidth - 10) * 10}">${message}</text>
                      <text x="${(labelWidth + messageWidth / 2) * 10}" y="140" transform="scale(.1)" textLength="${(messageWidth - 10) * 10}">${message}</text>
                    </g>
                  </svg>
                `;
            }

            // Main execution logic
            try {
              // --- 1. Load historical data ---
              console.log(`Loading historical data from ${historyFile} on branch ${branch}...`);
              const historyFileState = await getFile(historyFile);
              let historicalData = { clones: {}, views: {} };
              if (historyFileState.content) {
                historicalData = JSON.parse(historyFileState.content);
                console.log('Successfully loaded existing historical data.');
              } else {
                console.log('No historical data file found. A new one will be created.');
              }

              // --- 2. Fetch new traffic data ---
              console.log('Fetching latest traffic data from GitHub API...');
              const { data: clonesResponse } = await github.rest.repos.getClones({ owner, repo, per: 'day' });
              const { data: viewsResponse } = await github.rest.repos.getViews({ owner, repo, per: 'day' });

              // --- 3. Update historical data ---
              console.log('Merging new traffic data with historical data...');
              clonesResponse.clones.forEach(day => {
                const date = day.timestamp.split('T')[0];
                historicalData.clones[date] = { count: day.count, uniques: day.uniques };
              });
              viewsResponse.views.forEach(day => {
                const date = day.timestamp.split('T')[0];
                historicalData.views[date] = { count: day.count, uniques: day.uniques };
              });

              // --- 4. Calculate all-time totals ---
              const allTimeTotalClones = Object.values(historicalData.clones).reduce((sum, day) => sum + day.count, 0);
              const allTimeUniqueCloners = Object.values(historicalData.clones).reduce((sum, day) => sum + day.uniques, 0);
              const allTimeTotalViews = Object.values(historicalData.views).reduce((sum, day) => sum + day.count, 0);
              const allTimeUniqueVisitors = Object.values(historicalData.views).reduce((sum, day) => sum + day.uniques, 0);

              console.log(`All-Time Clones: Total=${allTimeTotalClones}, Unique (sum of daily uniques)=${allTimeUniqueCloners}`);
              console.log(`All-Time Views: Total=${allTimeTotalViews}, Unique (sum of daily uniques)=${allTimeUniqueVisitors}`);

              // --- 5. Generate new badge SVGs ---
              const clonesBadgeSvg = createBadgeSvg('Clones', `${allTimeTotalClones} (Unique: ${allTimeUniqueCloners})`, '#8FBCBB');
              const viewsBadgeSvg = createBadgeSvg('Views', `${allTimeTotalViews} (Unique: ${allTimeUniqueVisitors})`, '#88C0D0');

              // --- 6. Commit all files ---
              console.log('Committing updated files to the repository...');

              // Commit history file
              const newHistoryContent = JSON.stringify(historicalData, null, 2);
              await commitFile(historyFile, newHistoryContent, 'feat: Update GitHub traffic history', historyFileState.sha);
              console.log(`- Committed ${historyFile}`);

              // Get SHAs for existing badges before committing
              const clonesBadgeState = await getFile(`${badgeDir}/clones_badge.svg`);
              const viewsBadgeState = await getFile(`${badgeDir}/views_badge.svg`);

              // Commit badges
              await commitFile(`${badgeDir}/clones_badge.svg`, clonesBadgeSvg, 'feat: Update clones traffic badge', clonesBadgeState.sha);
              console.log(`- Committed ${badgeDir}/clones_badge.svg`);

              await commitFile(`${badgeDir}/views_badge.svg`, viewsBadgeSvg, 'feat: Update views traffic badge', viewsBadgeState.sha);
              console.log(`- Committed ${badgeDir}/views_badge.svg`);

              console.log('âœ… Traffic badges and history updated successfully!');

            } catch (error) {
              console.error('Error during workflow execution:', error);
              core.setFailed(`Action failed with error: ${error.message}`);
            }
